<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Summarising</title>

<script src="site_libs/header-attrs-2.14/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/yeti.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>




<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>


<link rel="stylesheet" href="style.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-inverse  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">R4SSP Semester 2 2022</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Modules
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-header">Intro</li>
    <li>
      <a href="01-intro.html">Intro to R and RStudio</a>
    </li>
    <li class="divider"></li>
    <li class="dropdown-header">Data Focus</li>
    <li>
      <a href="02-visualise.html">Part 1: Visualising</a>
    </li>
    <li>
      <a href="03-subset.html">Part 2: Subsetting</a>
    </li>
    <li>
      <a href="04-summarise.html">Part 3: Summarising</a>
    </li>
    <li>
      <a href="05-transform.html">Part 4: Transforming</a>
    </li>
    <li>
      <a href="06-communicate.html">Part 5: Communicating</a>
    </li>
    <li class="divider"></li>
    <li class="dropdown-header">Programming focus</li>
    <li>
      <a href="07-functions.html">Functions and Choices</a>
    </li>
    <li>
      <a href="08-iterate.html">Repeating Code</a>
    </li>
    <li>
      <a href="09-workflows.html">Workflows</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Zoom Notes
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="zoom_notes_01.html">01 - Introducing R and RStudio</a>
    </li>
    <li>
      <a href="zoom_notes_02.html">02 - Visualising data</a>
    </li>
    <li>
      <a href="zoom_notes_03.html">03 - Subsetting data</a>
    </li>
    <li>
      <a href="zoom_notes_04.html">04 - Summarising data</a>
    </li>
    <li>
      <a href="zoom_notes_05.html">05 - Transforming data</a>
    </li>
    <li>
      <a href="zoom_notes_06.html">06 - Communicating data</a>
    </li>
    <li>
      <a href="zoom_notes_07.html">07 - Functions and Choices</a>
    </li>
    <li>
      <a href="zoom_notes_08.html">08 - Repeating Code</a>
    </li>
    <li>
      <a href="zoom_notes_09.html">09 - Workflows</a>
    </li>
  </ul>
</li>
<li>
  <a href="about.html">About</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
<li role="separator" class="divider"></li>
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Summarising</h1>
<h4 class="date">Semester 2, 2022</h4>

</div>


<blockquote>
<h4 id="associated-material">Associated Material</h4>
<p>Zoom notes: <a href="zoom_notes_04.html">Zoom Notes 04 - Summarising
data</a></p>
<p>Readings</p>
<ul>
<li><a href="https://r4ds.had.co.nz/exploratory-data-analysis.html">R
for Data Science - Chapter 7</a></li>
</ul>
</blockquote>
<p><br />
</p>
<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>We do scientific research to test hypotheses, answer questions, or
just learn something about the world. After the often labourious process
of data collection, we may have hundreds (or even thousands) of data
points, but we haven’t actually learned anything. To squeeze the
knowledge out of our raw data, we must use statistics.</p>
<p>The formal topic of statistics is large and complex, and we do not
attempt to teach it here (there are papers for that, and we recommend
you take as many of them as possible). We concentrate on how to use R to
perform common statistical analyses. R is especially useful for such
tasks because of its extensive set of statistical libraries and
efficient data handling facilities.</p>
<p>There are two general types of statistical analyses – descriptive
statistics, which allow us to summarise and describe our raw data, and
inferential statistics, which allow us to generalise our results beyond
our observed data. We will only cover descriptive statistics in
R4SSP.</p>
<p>For this module, we will use two data sets – the Palmers Penguins
data we have seen previously, and a data set containing Chlorophyll A
(ChlA) readings from three New Zealand lakes (data provided by the local
Regional Councils). ChlA levels are an indicator of phytoplankton
biomass, and provide a general measure of lake health – more ChlA
indicates poorer health. The “toxic algal blooms” that occur
occasionally in New Zealand lakes are accompanied by a dramatic spike in
measured ChlA.</p>
<p><br />
</p>
<blockquote>
<p>Downloading the ChlA NZ Lakes data:</p>
<p>One option for downloading the data is to use
<code>download.file()</code> in R. You can use this command to download
the file into your <code>data/</code> directory:</p>
<pre class="r"><code>download.file(url = &quot;https://raw.githubusercontent.com/rtis-training/2022-s2-r4ssp/main/docs/data/NZ_lake_chla_data.csv&quot;, 
 destfile = &quot;data/NZ_lake_chla_data.csv&quot;)</code></pre>
<p><em>Remember that R is case sensitive so if you don’t have a
directory exactly called <code>data/</code> modify the command to match
your directory.</em></p>
<p>The second option is in a web browser go to <a
href="https://raw.githubusercontent.com/rtis-training/2022-s2-r4ssp/main/docs/data/NZ_lake_chla_data.csv"
class="uri">https://raw.githubusercontent.com/rtis-training/2022-s2-r4ssp/main/docs/data/NZ_lake_chla_data.csv</a>
and then save the page using <code>Save As</code> and give it the name
“NZ_lake_chla_data.csv”. Save it to your data location.</p>
</blockquote>
<p><br />
</p>
</div>
<div id="loading-the-data" class="section level1">
<h1>Loading the data</h1>
<pre class="r"><code>#===============================================
# The Penguin Data:
#===============================================

# Install palmerpenguins once on any computer

# install.packages(&quot;palmerspenguins&quot;)

# After loading the library, a tibble
# called &#39;penguins&#39; will be initialised
library(palmerpenguins)

# Check the structure
str(penguins)
#&gt; tibble [344 × 8] (S3: tbl_df/tbl/data.frame)
#&gt;  $ species          : Factor w/ 3 levels &quot;Adelie&quot;,&quot;Chinstrap&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...
#&gt;  $ island           : Factor w/ 3 levels &quot;Biscoe&quot;,&quot;Dream&quot;,..: 3 3 3 3 3 3 3 3 3 3 ...
#&gt;  $ bill_length_mm   : num [1:344] 39.1 39.5 40.3 NA 36.7 39.3 38.9 39.2 34.1 42 ...
#&gt;  $ bill_depth_mm    : num [1:344] 18.7 17.4 18 NA 19.3 20.6 17.8 19.6 18.1 20.2 ...
#&gt;  $ flipper_length_mm: int [1:344] 181 186 195 NA 193 190 181 195 193 190 ...
#&gt;  $ body_mass_g      : int [1:344] 3750 3800 3250 NA 3450 3650 3625 4675 3475 4250 ...
#&gt;  $ sex              : Factor w/ 2 levels &quot;female&quot;,&quot;male&quot;: 2 1 1 NA 1 2 1 2 NA NA ...
#&gt;  $ year             : int [1:344] 2007 2007 2007 2007 2007 2007 2007 2007 2007 2007 ...

#===============================================
# The Lake Data:
#===============================================

# Read in the lakes data file, parsing the lake 
# name column as a factor
lakes &lt;- read.csv(&quot;data/NZ_lake_chla_data.csv&quot;, stringsAsFactors = TRUE)

# Since they are conceptually categorical in this data set, 
# you may wish to cast Year and Month to factors as well, for completeness...
lakes$Year &lt;- as.factor(lakes$Year)
lakes$Month &lt;- as.factor(lakes$Month)  

# Check the structure
str(lakes)
#&gt; &#39;data.frame&#39;:    408 obs. of  4 variables:
#&gt;  $ LakeName: Factor w/ 3 levels &quot;Lake Ellesmere&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...
#&gt;  $ Year    : Factor w/ 13 levels &quot;2001&quot;,&quot;2002&quot;,..: 4 4 4 4 4 4 4 4 4 4 ...
#&gt;  $ Month   : Factor w/ 12 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,..: 1 2 3 4 5 6 7 8 9 10 ...
#&gt;  $ ChlA    : num  66.9 79.9 95 82.4 59.6 69 62.1 96.3 135 102 ...</code></pre>
</div>
<div id="visualise-the-data-revision" class="section level1">
<h1>Visualise the data (revision)</h1>
<p>When faced with a new data set, my first step is invariably to start
making graphs. These “pictures” of your data provide an easy way to see
large-scale patterns that will help guide your further analysis. They
also help you to catch any problems in your data (see the skewness
exercise in the Zoom Notes for this module) that must be addressed
before proceeding to more complex analyses.</p>
<p>An excellent first graph for continuous (i.e. not categorical) data
is the <strong>frequency distribution</strong>, or
<strong>histogram</strong>, which has data value on the x-axis and
frequency (i.e. count or proportion) on the y-axis. This shows you, in a
single picture, how your data are distributed. We met the histogram in
Module 02.</p>
<p>The <code>penguins</code> data set contains values for 344 different
penguins. We can begin by looking at how the penguins’ body weights are
distributed.</p>
<div id="histogram-with-base-r" class="section level2">
<h2>Histogram with base R</h2>
<pre class="r"><code># The &#39;breaks&#39; argument controls the number of bars drawn
hist(penguins$body_mass_g, 
     breaks = 100,
     main=&quot;Distribution of Penguin Body Mass&quot;, xlab = &quot;Body mass (g)&quot;, ylab = &quot;Frequency&quot;)</code></pre>
<p><img src="figures/04/04-histograms-1.png" width="672" /></p>
</div>
<div id="histogram-with-ggplot" class="section level2">
<h2>Histogram with ggplot</h2>
<pre class="r"><code># Load the library before your first call to ggplot
library(ggplot2)

# The values provided to &#39;colour&#39; and &#39;fill&#39; are hexidecimal colour codes. Note the 
# hash mark prefix. It is required.
ggplot(data = penguins, mapping = aes(x = body_mass_g)) +
  geom_histogram(colour = &quot;#7133ff&quot;, fill=&quot;#bbbbff&quot;) +
  labs(title = &quot;Distribution of Penguin Body Mass&quot;, 
       x = &quot;Body Mass (g)&quot;, 
       y = &quot;Frequency&quot;) + theme_bw()</code></pre>
<p><img src="figures/04/ggplot%20histo,%20-1.png" width="672" /></p>
</div>
<div id="illustrating-groups" class="section level2">
<h2>Illustrating Groups</h2>
<p>Using ggplot, we can illustrate group effects in histograms by
defining a mapping from a grouping (i.e. categorical) variable to the
<code>fill</code> property of function <code>geom_histogram</code>. For
example, the code below will make histograms of all the ChlA values in
data frame <code>lakes</code>, with each lake in a different colour</p>
<p>By default, geom_histogram produces a stacked plot – that is, the
different groups are shown stacked up in a single bar, separated by
their colour. To make the plot with side-by-side bars, set
geom_histogram’s <code>position</code> argument to <code>dodge</code>.
Note that this is not a mapping, it is simply an argument to function
geom_histogram. What does this simple graph tell you about the health of
these three lakes?</p>
<div id="for-continuous-data" class="section level3">
<h3>For continuous data</h3>
<pre class="r"><code># Stacked grouped histogram
ggplot(data = lakes, mapping = aes(x = ChlA)) +
  geom_histogram(aes(fill=LakeName), colour = &#39;black&#39;)</code></pre>
<p><img src="figures/04/04-lake_hists-1.png" width="672" /></p>
<pre class="r"><code>
# Side-by-side grouped histogram
ggplot(data = lakes, mapping = aes(x = ChlA)) +
  geom_histogram(aes(fill=LakeName), colour = &#39;black&#39;, position=&quot;dodge&quot;)</code></pre>
<p><img src="figures/04/04-lake_hists-2.png" width="672" /></p>
</div>
<div id="for-categorical-data" class="section level3">
<h3>For categorical data</h3>
<p>The functions <code>hist</code> and <code>geom_histogram</code> are
appropriate for <strong>continuous</strong> (numerical) data. For
<strong>categorical</strong> variables (e.g. Species and Island in the
penguin data set) one often uses the more general <code>geom_bar</code>
function (geom_histogram is a special case of geom_bar). The example
code below shows how to generate a bar graph in ggplot, modifying the
default ggplot colour palette to something more accessible to viewers
with atypical colour vision:</p>
<pre class="r"><code># &quot;Colour-blind friendly&quot; palette from #https://personal.sron.nl/~pault/
# These are hexadecimal colour codes. The # is required.
customPalette &lt;- c(&quot;#DDAA33&quot;, &quot;#BB5566&quot;, &quot;#004488&quot;)

# Generate a stacked bar plot, and use our custom colour palette
ggplot(data = penguins, mapping = aes(x = island, fill=species)) +
  geom_bar() +
  scale_fill_manual(values = customPalette)</code></pre>
<p><img src="figures/04/04-categorical_distribution-1.png" width="672" /></p>
<p>As with geom_histogram above, we set the position argument of
geom_bar to change from stacked to side-by-side format.</p>
<p><img src="figures/04/04-categorical_distribution_dodge-1.png" width="672" /></p>
<p>Even a simple graph like this helps you to get to know your data.
Just by inspection we see that Biscoe island has the largest population,
Torgersen has only Adelie penguins, Dream Island has nearly equal
numbers of Chinstrap and Gentoo, etc. When first approaching a big data
set, always think about starting with some graphs.</p>
</div>
</div>
</div>
<div id="measures-of-central-tendency" class="section level1">
<h1>Measures of Central Tendency</h1>
<p>Look at the graph you made earlier showing the distributions of ChlA
for the three lakes. You might describe the Lake Ellesmere ChlA readings
as “mostly between 50 and 100” and the Lake Rotorua readings as “mostly
around 10”. Statements like this are attempts to describe a
<strong>typical</strong> score from a large data set. They allow us to
capture the fact that, for example, <em>overall</em>, Lake Ellesmere has
higher ChlA readings than Lake Rotorua. It is not the case that
<em>every</em> Ellesmere reading is higher than <em>every</em> Rotorua
reading, but <strong>typically</strong> this is the case.</p>
<p>In statistics, a precise measure of such typicality is called a
<strong>Measure of Central Tendency</strong> (MCT). The most common MCTs
are the <strong>mean</strong>, the <strong>median</strong> and the
<strong>mode</strong>. These are, respectively, the mathematical
average, the middle score, and the most frequent score (or scores) in a
data set. There are some subtle statistical issues around which of the
three MCT is appropriate for any given data analysis situation (ask your
lecturer for details), but they are all easy to compute in R (we have,
in fact, already met function <code>mean</code> in earlier modules), and
we show example code below for computing these descriptive statistics on
a single column of data from the penguins data set.</p>
<p>Note that the penguins data has some missing some values (cf. Module
03 - Subsetting), The functions for mean and median will not work if the
input data have any <code>NA</code> (missing) values. The most common
solution is to omit those scores from the computation by setting the
<code>na.rm</code> argument to <code>TRUE</code> as shown:</p>
<div id="mean" class="section level2">
<h2>Mean</h2>
<pre class="r"><code># We have seen this code before... We pass the column of interest
# to function mean
mean(penguins$body_mass_g, na.rm=TRUE)
#&gt; [1] 4201.754</code></pre>
</div>
<div id="median" class="section level2">
<h2>Median</h2>
<pre class="r"><code># The familiar pattern....
median(penguins$body_mass_g, na.rm = TRUE)
#&gt; [1] 4050</code></pre>
</div>
<div id="mode" class="section level2">
<h2>Mode</h2>
<p>Base R has no built-in function for mode. After Module 08 you will be
able to write your own Mode function. Or you can use one of several
available in auxiliary libraries. The DescTools library is a good
one.</p>
<pre class="r"><code>
# Install the package once on each machine
# install.packages(&quot;DescTools&quot;)

# Load the library once each session
library(DescTools)

#Call the function
Mode(penguins$body_mass_g, na.rm=TRUE)
#&gt; [1] 3800
#&gt; attr(,&quot;freq&quot;)
#&gt; [1] 12</code></pre>
<p>Note that DescTools::Mode returns the modal (i.e. most common value)
with an attached <strong>attribute</strong> called “freq” equal to the
number of occurrences.</p>
</div>
<div id="using-function-summary" class="section level2">
<h2>Using function <code>summary</code></h2>
<p>When you have a very large number of data measures, you may wish to
compute MCTs for individual columns as shown above. An efficient
alternative for smaller data sets is to use function
<code>summary</code>, which accepts a data frame and summarises
<em>all</em> its columns at once. Function <code>summary</code> computes
frequencies for categorical variables, and measures of central tendency
for continuous variables. It also reports the numbers of NA values in
each column. Function <code>summary</code> provides some additional
measures (minimum, 1st quartile, 3rd quartile, and maximum) that we will
discuss in more detail later.</p>
<pre class="r"><code>summary(penguins)
#&gt;       species          island    bill_length_mm  bill_depth_mm  
#&gt;  Adelie   :152   Biscoe   :168   Min.   :32.10   Min.   :13.10  
#&gt;  Chinstrap: 68   Dream    :124   1st Qu.:39.23   1st Qu.:15.60  
#&gt;  Gentoo   :124   Torgersen: 52   Median :44.45   Median :17.30  
#&gt;                                  Mean   :43.92   Mean   :17.15  
#&gt;                                  3rd Qu.:48.50   3rd Qu.:18.70  
#&gt;                                  Max.   :59.60   Max.   :21.50  
#&gt;                                  NA&#39;s   :2       NA&#39;s   :2      
#&gt;  flipper_length_mm  body_mass_g       sex           year     
#&gt;  Min.   :172.0     Min.   :2700   female:165   Min.   :2007  
#&gt;  1st Qu.:190.0     1st Qu.:3550   male  :168   1st Qu.:2007  
#&gt;  Median :197.0     Median :4050   NA&#39;s  : 11   Median :2008  
#&gt;  Mean   :200.9     Mean   :4202                Mean   :2008  
#&gt;  3rd Qu.:213.0     3rd Qu.:4750                3rd Qu.:2009  
#&gt;  Max.   :231.0     Max.   :6300                Max.   :2009  
#&gt;  NA&#39;s   :2         NA&#39;s   :2</code></pre>
<div id="exercise" class="section level3">
<h3>Exercise</h3>
<p>The results for column <code>year</code> may not be what you
expected. Function <code>summary</code> has computed an <em>average
value</em> for <code>year</code>. Does this seem like the appropriate
analysis? (Answer =&gt; No.) Modify <code>penguins</code> to make
<code>summary</code> treat the <code>year</code> data correctly, and
rerun <code>summary</code>.</p>
</div>
</div>
</div>
<div id="measures-of-variability" class="section level1">
<h1>Measures of Variability</h1>
<p>In the histograms for ChlA from each of three New Zealand lakes, the
three groups of scores did not overlap completely, indicating that the
typical values – the central tendencies – were different for the three
lakes. We can confirm this observation by comparing the means. We can
use function <code>aggregate</code> in base R, or <code>group_by</code>
and <code>summarise</code>, from library dplyr.</p>
<div id="using-aggregate" class="section level3">
<h3>Using <code>aggregate</code></h3>
<pre class="r"><code># Using aggregate. compute the group means
aggregate(lakes$ChlA, by = list(Lake = lakes$LakeName), FUN=mean)
#&gt;             Lake         x
#&gt; 1 Lake Ellesmere 80.566667
#&gt; 2   Lake Rotorua 18.419015
#&gt; 3     Lake Taupo  1.030606</code></pre>
</div>
<div id="using-group_by-and-summarise" class="section level3">
<h3>Using <code>group_by</code> and <code>summarise</code></h3>
<pre class="r"><code># Using `group_by` and `summarise`
library(dplyr)
#&gt; 
#&gt; Attaching package: &#39;dplyr&#39;
#&gt; The following objects are masked from &#39;package:stats&#39;:
#&gt; 
#&gt;     filter, lag
#&gt; The following objects are masked from &#39;package:base&#39;:
#&gt; 
#&gt;     intersect, setdiff, setequal, union

lakes %&gt;% 
  group_by(LakeName) %&gt;%
  summarise(MeanChlA = mean(ChlA))
#&gt; # A tibble: 3 × 2
#&gt;   LakeName       MeanChlA
#&gt;   &lt;fct&gt;             &lt;dbl&gt;
#&gt; 1 Lake Ellesmere    80.6 
#&gt; 2 Lake Rotorua      18.4 
#&gt; 3 Lake Taupo         1.03</code></pre>
<p>However, not only do the central points of the three lakes’
distributions differ, so do the amounts of “spread”. Lake Taupo’s
distribution is very “skinny”; all its readings are similar. Lake
Ellesmere is squashed and spread out; its readings vary a lot. Lake
Rotorua is intermediate. To illustrate this more clearly, we can use
ggplot to make separate graphs for each lake, using function
<code>facet_grid</code>.</p>
<p>Note the <code>scales</code> argument to <code>facet_grid</code>.
This allows each graph to adjust its y-axis to its data domain, which
makes the comparison visually easier; this should be mentioned in the
discussion of the figure in a manuscript.</p>
</div>
<div id="using-facet_grid" class="section level2">
<h2>Using <code>facet_grid</code></h2>
<pre class="r"><code>ggplot(data = lakes) +
  geom_histogram(aes(x = ChlA, fill=LakeName), color=&quot;black&quot;) +
  facet_grid(rows = vars(LakeName), scales=&quot;free_y&quot;)</code></pre>
<p><img src="figures/04/facet_graphs-1.png" width="672" /></p>
<p>Statistically, the “spread out” quality of a distribution reflects
its <strong>variability</strong>.</p>
<p>We can capture variability more precisely with measures of the
<strong>range</strong> of the data set. These are typically the smallest
and largest scores (minimum and maximum) and the scores at the 25th and
75th percentiles (also called <strong>1st quartile</strong> and
<strong>3rd quartile</strong>). Earlier, we saw that function
<code>summary</code> computes these measures of range. However, if we
simply pass the entire <code>lakes</code> data frame to function
<code>summary</code>, it will combine the data from all three lakes – to
compare the lakes we need the values from each lake separately.</p>
<p>In earlier modules we have seen two techniques for selecting out just
the rows from one lake (using [] or using <code>filter</code>). To run
function <code>summary</code> on each lake separately, we could select
the subset for each lake in turn, and pass each subset to
<code>summary</code>. However, we can achieve the same result more
parsimoniously by using function <code>aggregate</code>. Above we used
aggregate with <code>FUN = mean</code> to get the mean ChlA for each
lake. We can use <code>FUN = summary</code> to call function
<code>summary</code> separately for the records of each lake.</p>
<pre class="r"><code># Apply function summary by group
aggregate(lakes$ChlA, by = list(Lake = lakes$LakeName), FUN=summary)
#&gt;             Lake     x.Min.  x.1st Qu.   x.Median     x.Mean  x.3rd Qu.
#&gt; 1 Lake Ellesmere   1.300000  44.000000  67.950000  80.566667  97.087500
#&gt; 2   Lake Rotorua   2.500000  10.825000  15.950000  18.419015  23.625000
#&gt; 3     Lake Taupo   0.200000   0.600000   0.900000   1.030606   1.400000
#&gt;       x.Max.
#&gt; 1 521.300000
#&gt; 2  77.100000
#&gt; 3   2.900000</code></pre>
<p>We can also measure the variablity in a data set with the
<strong>standard deviation</strong>. The standard deviation is the most
commonly used measure of variability, and it plays an important
mathematical role in inferential statistics (ask your stats lecturer for
details – it’s very interesting). Conceptually, the standard deviation
is <em>almost</em> equal to the average distance from the mean across
all the values in a data set – it doesn’t equal <em>exactly</em> that
value, because of how it is computed, but it is close, and it can be
helpful to think of it with this approximation. Big standard deviation
shows that scores are spread far from their mean; small standard
deviation shows that scores tend to huddle close to their mean. Compute
standard deviation with function <code>sd</code>.</p>
<div id="using-aggregate-1" class="section level3">
<h3>Using <code>aggregate</code></h3>
<pre class="r"><code># Using aggregate. compute the group sds
aggregate(lakes$ChlA, by = list(Lake = lakes$LakeName), FUN=sd)
#&gt;             Lake          x
#&gt; 1 Lake Ellesmere 63.5217194
#&gt; 2   Lake Rotorua 11.6637583
#&gt; 3     Lake Taupo  0.5627233</code></pre>
</div>
<div id="using-group_by-and-summarise-1" class="section level3">
<h3>Using <code>group_by</code> and <code>summarise</code></h3>
<pre class="r"><code>lakes %&gt;% 
  group_by(LakeName) %&gt;%
  summarise(StdDev = sd(ChlA))
#&gt; # A tibble: 3 × 2
#&gt;   LakeName       StdDev
#&gt;   &lt;fct&gt;           &lt;dbl&gt;
#&gt; 1 Lake Ellesmere 63.5  
#&gt; 2 Lake Rotorua   11.7  
#&gt; 3 Lake Taupo      0.563</code></pre>
<p>The histograms, the measures of range, and the standard deviations
all indicate that Taupo has very stable ChlA measures, Rotorua is a
little noisier, and Ellesmere is all over the place. This phytoplankton
biomass stability is an important indicator of lake health – a stable
lake is at much lower risk of a toxic algal bloom.</p>
</div>
</div>
</div>
<div id="efficient-code-for-descriptive-statistics"
class="section level1">
<h1>Efficient code for descriptive statistics</h1>
<p>The function <code>describeBy</code> in package <code>psych</code>
will compute all the descriptive summaries we have seen (and a few more)
in one statement. When you are exploring a single data column and a
single grouping column (so the output doesn’t get too large), this is a
very useful function.</p>
<pre class="r"><code># Install once on any computer
#install.packages(&quot;psych&quot;)

# Call once each R session
library(psych)
#&gt; 
#&gt; Attaching package: &#39;psych&#39;
#&gt; The following objects are masked from &#39;package:DescTools&#39;:
#&gt; 
#&gt;     AUC, ICC, SD
#&gt; The following objects are masked from &#39;package:ggplot2&#39;:
#&gt; 
#&gt;     %+%, alpha

# Pass in the data column and the grouping column
describeBy(lakes$ChlA, lakes$LakeName)
#&gt; 
#&gt;  Descriptive statistics by group 
#&gt; group: Lake Ellesmere
#&gt;    vars   n  mean    sd median trimmed  mad min   max range skew kurtosis  se
#&gt; X1    1 120 80.57 63.52  67.95   72.45 40.7 1.3 521.3   520 3.12     17.5 5.8
#&gt; ------------------------------------------------------------ 
#&gt; group: Lake Rotorua
#&gt;    vars   n  mean    sd median trimmed  mad min  max range skew kurtosis   se
#&gt; X1    1 132 18.42 11.66  15.95   16.97 9.12 2.5 77.1  74.6 1.71     4.75 1.02
#&gt; ------------------------------------------------------------ 
#&gt; group: Lake Taupo
#&gt;    vars   n mean   sd median trimmed  mad min max range skew kurtosis   se
#&gt; X1    1 156 1.03 0.56    0.9    0.97 0.56 0.2 2.9   2.7 0.97      0.5 0.05</code></pre>
<p>Package <code>psych</code> contains many other interesting
statistical tools, especially for multivariate data sets commonly found
in psychological and ecological research. Ask Google or your lecturer
for details.</p>
</div>
<div id="exploring-the-relationship-between-two-variables"
class="section level1">
<h1>Exploring the relationship between two variables</h1>
<p>The preceding descriptive statistics all looked at data measures –
ChlA, bill length, body weight, etc. – individually, summarising their
distribution, central tendency and variability. Often, however, we are
interested in describing <strong>the relationship between data
measures</strong>. For example, we might want to know if heavier
penguins also tend to have longer bills. This type of relationship is
called a <strong>correlation</strong>. When we have more than one
measure for each experimental participant (or each penguin, or each
lake) we can explore correlations between pairs of measures graphically
with a <strong>scatterplot</strong>. A scatterplot has one measure on
each axis, and one point for each participant’s pair of scores.</p>
<p>In the code example below we make a scatterplot with ggplot
(cf. Module 02), and show how to add a <strong>linear trend
line</strong>. Conceptually, this is the line that runs through the
center of the scatterplot points, and it helps us to see the direction
of the relationship. Mathematically, trend lines are actually very
complicated things, and we generate them with the powerful function
<code>lm</code>,(for <strong>linear model</strong>). You will learn
about the many fascinating things you can do with linear modeling if you
take advanced statistics papers.</p>
<div id="scatterplot-with-linear-trend-line" class="section level2">
<h2>Scatterplot with linear trend line</h2>
<pre class="r"><code># geom_point plots the points of the scatterplot 

# geom_smooth plots the linear trend line computed with function lm

# The se argument determines whether error bars are shown 
# around the trend line.

ggplot(data = penguins, mapping = aes(x = body_mass_g, y = bill_length_mm)) +
  geom_point() +
  geom_smooth(method = &quot;lm&quot;, se=FALSE)</code></pre>
<p><img src="figures/04/04-scatterplot-1.png" width="672" /></p>
<p>The scatterplot gives us a very clear picture: those penguins with
higher body weights tend to also have longer bills, and this is
reflected in the positive slope of the trendline. Note however that this
is not an absolute rule. Is it easy to find pairs of points such that
the lighter of two penguins has the longer bill. This is typical of
correlational data.</p>
<p>There are various statistical measures that capture the strength of a
correlation (i.e. how close it is to being an absolute rule). For
continuous, numerical data (such as bill length and body weight) use the
R function <code>cor</code> to compute the numerical correlation value.
As with means and medians, we must tell <code>cor</code> how to cope
with missing data (NA scores). Unfortunately the syntax is not
consistent across the functions. For function <code>mean</code> we set
argument <code>na.rm = TRUE</code>. For function <code>cor</code> we
must set argument <code>use = "complete.obs"</code>, meaning that we
want the function to use only those rows that are complete (i.e. have
both values). These idiosyncracies occur from time to time in R; you
just have to learn them.</p>
</div>
<div id="correlation-coefficient" class="section level2">
<h2>Correlation coefficient</h2>
<pre class="r"><code>
# Pass the two data columns into function cor
cor(penguins$bill_length_mm, penguins$body_mass_g, use=&quot;complete.obs&quot;)
#&gt; [1] 0.5951098</code></pre>
<p>Function <code>cor</code> returns a value between -1 and 1.
Correlations that trend downward (i.e. if one score is high, the other
tends to be low) will have a negative correlation value. Correlations
that trend upward (i.e. if one score is high the other also tends to be
high) will have a positive correlation value. The closer the absolute
value of <code>cor</code> is to 1, the stronger the correlation (you
know who to talk to for more detail, don’t you?).</p>
<p>For example, consider these two scatterplots:</p>
<p><img src="figures/04/04-comparing-1.png" width="672" /></p>
</div>
<div id="exercise-1" class="section level2">
<h2>Exercise</h2>
<p>For one of the scatterplots above, the computed correlation score is
0.60. For the other, it is 0.87. First, predict which is which. Second,
write the necessary R code to confirm your prediction.</p>
</div>
</div>

<div id="rmd-source-code">LS0tCnRpdGxlOiAiU3VtbWFyaXNpbmciCmRhdGU6ICJTZW1lc3RlciAyLCAyMDIyIgpvdXRwdXQ6CiAgaHRtbF9kb2N1bWVudDoKICAgIHRvYzogdHJ1ZQogICAgdG9jX2Zsb2F0OiB0cnVlCiAgICB0b2NfZGVwdGg6IDMKICAgIGNvZGVfZG93bmxvYWQ6IHRydWUKICAgIGNvZGVfZm9sZGluZzogc2hvdwotLS0KCmBgYHtyIHNldHVwLCBpbmNsdWRlPUZBTFNFfQpsaWJyYXJ5KGtuaXRyKQoKa25pdHI6Om9wdHNfY2h1bmskc2V0KAogIGNvbW1lbnQgPSAiIz4iLAogIGZpZy5wYXRoID0gImZpZ3VyZXMvMDQvIiwgIyB1c2Ugb25seSBmb3Igc2luZ2xlIFJtZCBmaWxlcwogIGNvbGxhcHNlID0gVFJVRSwKICBlY2hvID0gVFJVRQopCgoKYGBgCgo+ICMjIyMgQXNzb2NpYXRlZCBNYXRlcmlhbAo+Cj4gWm9vbSBub3RlczogW1pvb20gTm90ZXMgMDQgLSBTdW1tYXJpc2luZyBkYXRhXSh6b29tX25vdGVzXzA0Lmh0bWwpCj4KPiBSZWFkaW5ncwo+Cj4gLSBbUiBmb3IgRGF0YSBTY2llbmNlIC0gQ2hhcHRlciA3XShodHRwczovL3I0ZHMuaGFkLmNvLm56L2V4cGxvcmF0b3J5LWRhdGEtYW5hbHlzaXMuaHRtbCkKClwKCiMgSW50cm9kdWN0aW9uCgpXZSBkbyBzY2llbnRpZmljIHJlc2VhcmNoIHRvIHRlc3QgaHlwb3RoZXNlcywgYW5zd2VyIHF1ZXN0aW9ucywgb3IganVzdCBsZWFybiBzb21ldGhpbmcgYWJvdXQgdGhlIHdvcmxkLiBBZnRlciB0aGUgb2Z0ZW4gbGFib3VyaW91cyBwcm9jZXNzIG9mIGRhdGEgY29sbGVjdGlvbiwgd2UgbWF5IGhhdmUgaHVuZHJlZHMgKG9yIGV2ZW4gdGhvdXNhbmRzKSBvZiBkYXRhIHBvaW50cywgYnV0IHdlIGhhdmVuJ3QgYWN0dWFsbHkgbGVhcm5lZCBhbnl0aGluZy4gVG8gc3F1ZWV6ZSB0aGUga25vd2xlZGdlIG91dCBvZiBvdXIgcmF3IGRhdGEsIHdlIG11c3QgdXNlIHN0YXRpc3RpY3MuCgpUaGUgZm9ybWFsIHRvcGljIG9mIHN0YXRpc3RpY3MgaXMgbGFyZ2UgYW5kIGNvbXBsZXgsIGFuZCB3ZSBkbyBub3QgYXR0ZW1wdCB0byB0ZWFjaCBpdCBoZXJlICh0aGVyZSBhcmUgcGFwZXJzIGZvciB0aGF0LCBhbmQgd2UgcmVjb21tZW5kIHlvdSB0YWtlIGFzIG1hbnkgb2YgdGhlbSBhcyBwb3NzaWJsZSkuIFdlIGNvbmNlbnRyYXRlIG9uIGhvdyB0byB1c2UgUiB0byBwZXJmb3JtIGNvbW1vbiBzdGF0aXN0aWNhbCBhbmFseXNlcy4gUiBpcyBlc3BlY2lhbGx5IHVzZWZ1bCBmb3Igc3VjaCB0YXNrcyBiZWNhdXNlIG9mIGl0cyBleHRlbnNpdmUgc2V0IG9mIHN0YXRpc3RpY2FsIGxpYnJhcmllcyBhbmQgZWZmaWNpZW50IGRhdGEgaGFuZGxpbmcgZmFjaWxpdGllcy4gCgpUaGVyZSBhcmUgdHdvIGdlbmVyYWwgdHlwZXMgb2Ygc3RhdGlzdGljYWwgYW5hbHlzZXMgLS0gZGVzY3JpcHRpdmUgc3RhdGlzdGljcywgd2hpY2ggYWxsb3cgdXMgdG8gc3VtbWFyaXNlIGFuZCBkZXNjcmliZSBvdXIgcmF3IGRhdGEsIGFuZCBpbmZlcmVudGlhbCBzdGF0aXN0aWNzLCB3aGljaCBhbGxvdyB1cyB0byBnZW5lcmFsaXNlIG91ciByZXN1bHRzIGJleW9uZCBvdXIgb2JzZXJ2ZWQgZGF0YS4gV2Ugd2lsbCBvbmx5IGNvdmVyIGRlc2NyaXB0aXZlIHN0YXRpc3RpY3MgaW4gUjRTU1AuCgpGb3IgdGhpcyBtb2R1bGUsIHdlIHdpbGwgdXNlIHR3byBkYXRhIHNldHMgLS0gdGhlIFBhbG1lcnMgUGVuZ3VpbnMgZGF0YSB3ZSBoYXZlIHNlZW4gcHJldmlvdXNseSwgYW5kIGEgZGF0YSBzZXQgY29udGFpbmluZyBDaGxvcm9waHlsbCBBIChDaGxBKSByZWFkaW5ncyBmcm9tIHRocmVlIE5ldyBaZWFsYW5kIGxha2VzIChkYXRhIHByb3ZpZGVkIGJ5IHRoZSBsb2NhbCBSZWdpb25hbCBDb3VuY2lscykuIENobEEgbGV2ZWxzIGFyZSBhbiBpbmRpY2F0b3Igb2YgcGh5dG9wbGFua3RvbiBiaW9tYXNzLCBhbmQgcHJvdmlkZSBhIGdlbmVyYWwgbWVhc3VyZSBvZiBsYWtlIGhlYWx0aCAtLSBtb3JlIENobEEgaW5kaWNhdGVzIHBvb3JlciBoZWFsdGguIFRoZSAidG94aWMgYWxnYWwgYmxvb21zIiB0aGF0IG9jY3VyIG9jY2FzaW9uYWxseSBpbiBOZXcgWmVhbGFuZCBsYWtlcyBhcmUgYWNjb21wYW5pZWQgYnkgYSBkcmFtYXRpYyBzcGlrZSBpbiBtZWFzdXJlZCBDaGxBLgoKXAoKPiBEb3dubG9hZGluZyB0aGUgQ2hsQSBOWiBMYWtlcyBkYXRhOgo+IAo+IE9uZSBvcHRpb24gZm9yIGRvd25sb2FkaW5nIHRoZSBkYXRhIGlzIHRvIHVzZSBgZG93bmxvYWQuZmlsZSgpYCBpbiBSLiBZb3UgY2FuIHVzZSB0aGlzIGNvbW1hbmQgdG8gZG93bmxvYWQgdGhlIGZpbGUgaW50byB5b3VyIGBkYXRhL2AgZGlyZWN0b3J5OiAKPiAKPiBgYGB7ciwgZXZhbCA9IEZBTFNFfQo+IGRvd25sb2FkLmZpbGUodXJsID0gImh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9ydGlzLXRyYWluaW5nLzIwMjItczItcjRzc3AvbWFpbi9kb2NzL2RhdGEvTlpfbGFrZV9jaGxhX2RhdGEuY3N2IiwgCj4gIGRlc3RmaWxlID0gImRhdGEvTlpfbGFrZV9jaGxhX2RhdGEuY3N2IikKPiBgYGAKPiBfUmVtZW1iZXIgdGhhdCBSIGlzIGNhc2Ugc2Vuc2l0aXZlIHNvIGlmIHlvdSBkb24ndCBoYXZlIGEgZGlyZWN0b3J5IGV4YWN0bHkgY2FsbGVkIGBkYXRhL2AgbW9kaWZ5IHRoZSBjb21tYW5kIHRvIG1hdGNoIHlvdXIgZGlyZWN0b3J5Ll8KPgo+IFRoZSBzZWNvbmQgb3B0aW9uIGlzIGluIGEgd2ViIGJyb3dzZXIgZ28gdG8gaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3J0aXMtdHJhaW5pbmcvMjAyMi1zMi1yNHNzcC9tYWluL2RvY3MvZGF0YS9OWl9sYWtlX2NobGFfZGF0YS5jc3YgYW5kIHRoZW4gc2F2ZSB0aGUgcGFnZSB1c2luZyBgU2F2ZSBBc2AgYW5kIGdpdmUgaXQgdGhlIG5hbWUgIk5aX2xha2VfY2hsYV9kYXRhLmNzdiIuIFNhdmUgaXQgdG8geW91ciBkYXRhIGxvY2F0aW9uLgoKXAoKIyBMb2FkaW5nIHRoZSBkYXRhCgpgYGB7ciBsb2FkIHRoZSBkYXRhLCB3YXJuaW5nPUZBTFNFLCBtZXNzYWdlPUZBTFNFfQojPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KIyBUaGUgUGVuZ3VpbiBEYXRhOgojPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KCiMgSW5zdGFsbCBwYWxtZXJwZW5ndWlucyBvbmNlIG9uIGFueSBjb21wdXRlcgoKIyBpbnN0YWxsLnBhY2thZ2VzKCJwYWxtZXJzcGVuZ3VpbnMiKQoKIyBBZnRlciBsb2FkaW5nIHRoZSBsaWJyYXJ5LCBhIHRpYmJsZQojIGNhbGxlZCAncGVuZ3VpbnMnIHdpbGwgYmUgaW5pdGlhbGlzZWQKbGlicmFyeShwYWxtZXJwZW5ndWlucykKCiMgQ2hlY2sgdGhlIHN0cnVjdHVyZQpzdHIocGVuZ3VpbnMpCgojPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KIyBUaGUgTGFrZSBEYXRhOgojPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KCiMgUmVhZCBpbiB0aGUgbGFrZXMgZGF0YSBmaWxlLCBwYXJzaW5nIHRoZSBsYWtlIAojIG5hbWUgY29sdW1uIGFzIGEgZmFjdG9yCmxha2VzIDwtIHJlYWQuY3N2KCJkYXRhL05aX2xha2VfY2hsYV9kYXRhLmNzdiIsIHN0cmluZ3NBc0ZhY3RvcnMgPSBUUlVFKQoKIyBTaW5jZSB0aGV5IGFyZSBjb25jZXB0dWFsbHkgY2F0ZWdvcmljYWwgaW4gdGhpcyBkYXRhIHNldCwgCiMgeW91IG1heSB3aXNoIHRvIGNhc3QgWWVhciBhbmQgTW9udGggdG8gZmFjdG9ycyBhcyB3ZWxsLCBmb3IgY29tcGxldGVuZXNzLi4uCmxha2VzJFllYXIgPC0gYXMuZmFjdG9yKGxha2VzJFllYXIpCmxha2VzJE1vbnRoIDwtIGFzLmZhY3RvcihsYWtlcyRNb250aCkgIAoKIyBDaGVjayB0aGUgc3RydWN0dXJlCnN0cihsYWtlcykKYGBgCgojIFZpc3VhbGlzZSB0aGUgZGF0YSAocmV2aXNpb24pCgpXaGVuIGZhY2VkIHdpdGggYSBuZXcgZGF0YSBzZXQsIG15IGZpcnN0IHN0ZXAgaXMgaW52YXJpYWJseSB0byBzdGFydCBtYWtpbmcgZ3JhcGhzLiBUaGVzZSAicGljdHVyZXMiIG9mIHlvdXIgZGF0YSBwcm92aWRlIGFuIGVhc3kgd2F5IHRvIHNlZSBsYXJnZS1zY2FsZSBwYXR0ZXJucyB0aGF0IHdpbGwgaGVscCBndWlkZSB5b3VyIGZ1cnRoZXIgYW5hbHlzaXMuIFRoZXkgYWxzbyBoZWxwIHlvdSB0byBjYXRjaCBhbnkgcHJvYmxlbXMgaW4geW91ciBkYXRhIChzZWUgdGhlIHNrZXduZXNzIGV4ZXJjaXNlIGluIHRoZSBab29tIE5vdGVzIGZvciB0aGlzIG1vZHVsZSkgdGhhdCBtdXN0IGJlIGFkZHJlc3NlZCBiZWZvcmUgcHJvY2VlZGluZyB0byBtb3JlIGNvbXBsZXggYW5hbHlzZXMuCgpBbiBleGNlbGxlbnQgZmlyc3QgZ3JhcGggZm9yIGNvbnRpbnVvdXMgKGkuZS4gbm90IGNhdGVnb3JpY2FsKSBkYXRhIGlzIHRoZSAqKmZyZXF1ZW5jeSBkaXN0cmlidXRpb24qKiwgIG9yICoqaGlzdG9ncmFtKiosIHdoaWNoIGhhcyBkYXRhIHZhbHVlIG9uIHRoZSB4LWF4aXMgYW5kIGZyZXF1ZW5jeSAoaS5lLiBjb3VudCBvciBwcm9wb3J0aW9uKSBvbiB0aGUgeS1heGlzLiBUaGlzIHNob3dzIHlvdSwgaW4gYSBzaW5nbGUgcGljdHVyZSwgaG93IHlvdXIgZGF0YSBhcmUgZGlzdHJpYnV0ZWQuIFdlIG1ldCB0aGUgaGlzdG9ncmFtIGluIE1vZHVsZSAwMi4gCgpUaGUgYHBlbmd1aW5zYCBkYXRhIHNldCBjb250YWlucyB2YWx1ZXMgZm9yIDM0NCBkaWZmZXJlbnQgcGVuZ3VpbnMuIFdlIGNhbiBiZWdpbiBieSBsb29raW5nIGF0IGhvdyB0aGUgcGVuZ3VpbnMnIGJvZHkgd2VpZ2h0cyBhcmUgZGlzdHJpYnV0ZWQuIAoKIyMgSGlzdG9ncmFtIHdpdGggYmFzZSBSCgpgYGB7ciAwNC1oaXN0b2dyYW1zLCB3YXJuaW5nPUZBTFNFLCBtZXNzYWdlPUZBTFNFfQojIFRoZSAnYnJlYWtzJyBhcmd1bWVudCBjb250cm9scyB0aGUgbnVtYmVyIG9mIGJhcnMgZHJhd24KaGlzdChwZW5ndWlucyRib2R5X21hc3NfZywgCiAgICAgYnJlYWtzID0gMTAwLAogICAgIG1haW49IkRpc3RyaWJ1dGlvbiBvZiBQZW5ndWluIEJvZHkgTWFzcyIsIHhsYWIgPSAiQm9keSBtYXNzIChnKSIsIHlsYWIgPSAiRnJlcXVlbmN5IikKYGBgCgojIyBIaXN0b2dyYW0gd2l0aCBnZ3Bsb3QKCmBgYHtyIGdncGxvdCBoaXN0bywgLCB3YXJuaW5nPUZBTFNFLCBtZXNzYWdlPUZBTFNFfQojIExvYWQgdGhlIGxpYnJhcnkgYmVmb3JlIHlvdXIgZmlyc3QgY2FsbCB0byBnZ3Bsb3QKbGlicmFyeShnZ3Bsb3QyKQoKIyBUaGUgdmFsdWVzIHByb3ZpZGVkIHRvICdjb2xvdXInIGFuZCAnZmlsbCcgYXJlIGhleGlkZWNpbWFsIGNvbG91ciBjb2Rlcy4gTm90ZSB0aGUgCiMgaGFzaCBtYXJrIHByZWZpeC4gSXQgaXMgcmVxdWlyZWQuCmdncGxvdChkYXRhID0gcGVuZ3VpbnMsIG1hcHBpbmcgPSBhZXMoeCA9IGJvZHlfbWFzc19nKSkgKwogIGdlb21faGlzdG9ncmFtKGNvbG91ciA9ICIjNzEzM2ZmIiwgZmlsbD0iI2JiYmJmZiIpICsKICBsYWJzKHRpdGxlID0gIkRpc3RyaWJ1dGlvbiBvZiBQZW5ndWluIEJvZHkgTWFzcyIsIAogICAgICAgeCA9ICJCb2R5IE1hc3MgKGcpIiwgCiAgICAgICB5ID0gIkZyZXF1ZW5jeSIpICsgdGhlbWVfYncoKQpgYGAKCiMjIElsbHVzdHJhdGluZyBHcm91cHMKClVzaW5nIGdncGxvdCwgd2UgY2FuIGlsbHVzdHJhdGUgZ3JvdXAgZWZmZWN0cyBpbiBoaXN0b2dyYW1zIGJ5IGRlZmluaW5nIGEgbWFwcGluZyBmcm9tIGEgZ3JvdXBpbmcgKGkuZS4gY2F0ZWdvcmljYWwpIHZhcmlhYmxlIHRvIHRoZSBgZmlsbGAgcHJvcGVydHkgb2YgZnVuY3Rpb24gYGdlb21faGlzdG9ncmFtYC4gRm9yIGV4YW1wbGUsIHRoZSBjb2RlIGJlbG93IHdpbGwgbWFrZSBoaXN0b2dyYW1zIG9mIGFsbCB0aGUgQ2hsQSB2YWx1ZXMgaW4gZGF0YSBmcmFtZSBgbGFrZXNgLCB3aXRoIGVhY2ggbGFrZSBpbiBhIGRpZmZlcmVudCBjb2xvdXIKCkJ5IGRlZmF1bHQsIGdlb21faGlzdG9ncmFtIHByb2R1Y2VzIGEgc3RhY2tlZCBwbG90IC0tIHRoYXQgaXMsIHRoZSBkaWZmZXJlbnQgZ3JvdXBzIGFyZSBzaG93biBzdGFja2VkIHVwIGluIGEgc2luZ2xlIGJhciwgc2VwYXJhdGVkIGJ5IHRoZWlyIGNvbG91ci4gVG8gbWFrZSB0aGUgcGxvdCB3aXRoIHNpZGUtYnktc2lkZSBiYXJzLCBzZXQgZ2VvbV9oaXN0b2dyYW0ncyBgcG9zaXRpb25gIGFyZ3VtZW50IHRvIGBkb2RnZWAuIE5vdGUgdGhhdCB0aGlzIGlzIG5vdCBhIG1hcHBpbmcsIGl0IGlzIHNpbXBseSBhbiBhcmd1bWVudCB0byBmdW5jdGlvbiBnZW9tX2hpc3RvZ3JhbS4gV2hhdCBkb2VzIHRoaXMgc2ltcGxlIGdyYXBoIHRlbGwgeW91IGFib3V0IHRoZSBoZWFsdGggb2YgdGhlc2UgdGhyZWUgbGFrZXM/CgojIyMgRm9yIGNvbnRpbnVvdXMgZGF0YQoKYGBge3IgMDQtbGFrZV9oaXN0cywgd2FybmluZz1GQUxTRSwgbWVzc2FnZT1GQUxTRX0KIyBTdGFja2VkIGdyb3VwZWQgaGlzdG9ncmFtCmdncGxvdChkYXRhID0gbGFrZXMsIG1hcHBpbmcgPSBhZXMoeCA9IENobEEpKSArCiAgZ2VvbV9oaXN0b2dyYW0oYWVzKGZpbGw9TGFrZU5hbWUpLCBjb2xvdXIgPSAnYmxhY2snKQoKIyBTaWRlLWJ5LXNpZGUgZ3JvdXBlZCBoaXN0b2dyYW0KZ2dwbG90KGRhdGEgPSBsYWtlcywgbWFwcGluZyA9IGFlcyh4ID0gQ2hsQSkpICsKICBnZW9tX2hpc3RvZ3JhbShhZXMoZmlsbD1MYWtlTmFtZSksIGNvbG91ciA9ICdibGFjaycsIHBvc2l0aW9uPSJkb2RnZSIpCgpgYGAKCiMjIyBGb3IgY2F0ZWdvcmljYWwgZGF0YQoKVGhlIGZ1bmN0aW9ucyBgaGlzdGAgYW5kIGBnZW9tX2hpc3RvZ3JhbWAgYXJlIGFwcHJvcHJpYXRlIGZvciAqKmNvbnRpbnVvdXMqKiAobnVtZXJpY2FsKSBkYXRhLiBGb3IgKipjYXRlZ29yaWNhbCoqIHZhcmlhYmxlcyAoZS5nLiBTcGVjaWVzIGFuZCBJc2xhbmQgaW4gdGhlIHBlbmd1aW4gZGF0YSBzZXQpIG9uZSBvZnRlbiB1c2VzIHRoZSBtb3JlIGdlbmVyYWwgYGdlb21fYmFyYCBmdW5jdGlvbiAoZ2VvbV9oaXN0b2dyYW0gaXMgYSBzcGVjaWFsIGNhc2Ugb2YgZ2VvbV9iYXIpLiBUaGUgZXhhbXBsZSBjb2RlIGJlbG93IHNob3dzIGhvdyB0byBnZW5lcmF0ZSBhIGJhciBncmFwaCBpbiBnZ3Bsb3QsIG1vZGlmeWluZyB0aGUgZGVmYXVsdCBnZ3Bsb3QgY29sb3VyIHBhbGV0dGUgdG8gc29tZXRoaW5nIG1vcmUgYWNjZXNzaWJsZSB0byB2aWV3ZXJzIHdpdGggYXR5cGljYWwgY29sb3VyIHZpc2lvbjoKCmBgYHtyIDA0LWNhdGVnb3JpY2FsX2Rpc3RyaWJ1dGlvbn0KIyAiQ29sb3VyLWJsaW5kIGZyaWVuZGx5IiBwYWxldHRlIGZyb20gI2h0dHBzOi8vcGVyc29uYWwuc3Jvbi5ubC9+cGF1bHQvCiMgVGhlc2UgYXJlIGhleGFkZWNpbWFsIGNvbG91ciBjb2Rlcy4gVGhlICMgaXMgcmVxdWlyZWQuCmN1c3RvbVBhbGV0dGUgPC0gYygiI0REQUEzMyIsICIjQkI1NTY2IiwgIiMwMDQ0ODgiKQoKIyBHZW5lcmF0ZSBhIHN0YWNrZWQgYmFyIHBsb3QsIGFuZCB1c2Ugb3VyIGN1c3RvbSBjb2xvdXIgcGFsZXR0ZQpnZ3Bsb3QoZGF0YSA9IHBlbmd1aW5zLCBtYXBwaW5nID0gYWVzKHggPSBpc2xhbmQsIGZpbGw9c3BlY2llcykpICsKICBnZW9tX2JhcigpICsKICBzY2FsZV9maWxsX21hbnVhbCh2YWx1ZXMgPSBjdXN0b21QYWxldHRlKQpgYGAKCkFzIHdpdGggZ2VvbV9oaXN0b2dyYW0gYWJvdmUsIHdlIHNldCB0aGUgcG9zaXRpb24gYXJndW1lbnQgb2YgZ2VvbV9iYXIgdG8gY2hhbmdlIGZyb20gc3RhY2tlZCB0byBzaWRlLWJ5LXNpZGUgZm9ybWF0LgoKYGBge3IgMDQtY2F0ZWdvcmljYWxfZGlzdHJpYnV0aW9uX2RvZGdlLCBlY2hvPUZBTFNFLCB3YXJuaW5nPUZBTFNFLCBtZXNzYWdlPUZBTFNFfQoKIyAiQ29sb3VyLWJsaW5kIGZyaWVuZGx5IiBwYWxldHRlIGZyb20gI2h0dHBzOi8vcGVyc29uYWwuc3Jvbi5ubC9+cGF1bHQvCiMgVGhlc2UgYXJlIGhleGFkZWNpbWFsIGNvbG91ciBjb2Rlcy4gVGhlICMgaXMgcmVxdWlyZWQuCmN1c3RvbVBhbGV0dGUgPC0gYygiI0REQUEzMyIsICIjQkI1NTY2IiwgIiMwMDQ0ODgiKQoKIyBHZW5lcmF0ZSBhIHN0YWNrZWQgYmFyIHBsb3QsIGFuZCB1c2Ugb3VyIGN1c3RvbSBjb2xvdXIgcGFsZXR0ZQpnZ3Bsb3QoZGF0YSA9IHBlbmd1aW5zLCBtYXBwaW5nID0gYWVzKHggPSBpc2xhbmQsIGZpbGw9c3BlY2llcykpICsKICBnZW9tX2Jhcihwb3NpdGlvbiA9ICJkb2RnZSIsIGNvbG9yID0gImJsYWNrIikgKwogIHNjYWxlX2ZpbGxfbWFudWFsKHZhbHVlcyA9IGN1c3RvbVBhbGV0dGUpCmBgYAoKRXZlbiBhIHNpbXBsZSBncmFwaCBsaWtlIHRoaXMgaGVscHMgeW91IHRvIGdldCB0byBrbm93IHlvdXIgZGF0YS4gSnVzdCBieSBpbnNwZWN0aW9uIHdlIHNlZSB0aGF0IEJpc2NvZSBpc2xhbmQgaGFzIHRoZSBsYXJnZXN0IHBvcHVsYXRpb24sIFRvcmdlcnNlbiBoYXMgb25seSBBZGVsaWUgcGVuZ3VpbnMsIERyZWFtIElzbGFuZCBoYXMgbmVhcmx5IGVxdWFsIG51bWJlcnMgb2YgQ2hpbnN0cmFwIGFuZCBHZW50b28sIGV0Yy4gV2hlbiBmaXJzdCBhcHByb2FjaGluZyBhIGJpZyBkYXRhIHNldCwgYWx3YXlzIHRoaW5rIGFib3V0IHN0YXJ0aW5nIHdpdGggc29tZSBncmFwaHMuCgoKIyBNZWFzdXJlcyBvZiBDZW50cmFsIFRlbmRlbmN5CgpMb29rIGF0IHRoZSBncmFwaCB5b3UgbWFkZSBlYXJsaWVyIHNob3dpbmcgdGhlIGRpc3RyaWJ1dGlvbnMgb2YgQ2hsQSBmb3IgdGhlIHRocmVlIGxha2VzLiBZb3UgbWlnaHQgZGVzY3JpYmUgdGhlIExha2UgRWxsZXNtZXJlIENobEEgcmVhZGluZ3MgYXMgIm1vc3RseSBiZXR3ZWVuIDUwIGFuZCAxMDAiIGFuZCB0aGUgTGFrZSBSb3RvcnVhIHJlYWRpbmdzIGFzICJtb3N0bHkgYXJvdW5kIDEwIi4gIFN0YXRlbWVudHMgbGlrZSB0aGlzIGFyZSBhdHRlbXB0cyB0byBkZXNjcmliZSBhICoqdHlwaWNhbCoqIHNjb3JlIGZyb20gYSBsYXJnZSBkYXRhIHNldC4gVGhleSBhbGxvdyB1cyB0byBjYXB0dXJlIHRoZSBmYWN0IHRoYXQsIGZvciBleGFtcGxlLCAqb3ZlcmFsbCosIExha2UgRWxsZXNtZXJlIGhhcyBoaWdoZXIgQ2hsQSByZWFkaW5ncyB0aGFuIExha2UgUm90b3J1YS4gSXQgaXMgbm90IHRoZSBjYXNlIHRoYXQgKmV2ZXJ5KiBFbGxlc21lcmUgcmVhZGluZyBpcyBoaWdoZXIgdGhhbiAqZXZlcnkqIFJvdG9ydWEgcmVhZGluZywgYnV0ICoqdHlwaWNhbGx5KiogdGhpcyBpcyB0aGUgY2FzZS4gCgpJbiBzdGF0aXN0aWNzLCBhIHByZWNpc2UgbWVhc3VyZSBvZiBzdWNoIHR5cGljYWxpdHkgaXMgY2FsbGVkIGEgKipNZWFzdXJlIG9mIENlbnRyYWwgVGVuZGVuY3kqKiAoTUNUKS4gVGhlIG1vc3QgY29tbW9uIE1DVHMgYXJlIHRoZSAqKm1lYW4qKiwgdGhlICoqbWVkaWFuKiogYW5kIHRoZSAqKm1vZGUqKi4gVGhlc2UgYXJlLCByZXNwZWN0aXZlbHksIHRoZSBtYXRoZW1hdGljYWwgYXZlcmFnZSwgdGhlIG1pZGRsZSBzY29yZSwgYW5kIHRoZSBtb3N0IGZyZXF1ZW50IHNjb3JlIChvciBzY29yZXMpIGluIGEgZGF0YSBzZXQuIFRoZXJlIGFyZSBzb21lIHN1YnRsZSBzdGF0aXN0aWNhbCBpc3N1ZXMgYXJvdW5kIHdoaWNoIG9mIHRoZSB0aHJlZSBNQ1QgaXMgYXBwcm9wcmlhdGUgZm9yIGFueSBnaXZlbiBkYXRhIGFuYWx5c2lzIHNpdHVhdGlvbiAoYXNrIHlvdXIgbGVjdHVyZXIgZm9yIGRldGFpbHMpLCBidXQgdGhleSBhcmUgYWxsIGVhc3kgdG8gY29tcHV0ZSBpbiBSICh3ZSBoYXZlLCBpbiBmYWN0LCBhbHJlYWR5IG1ldCBmdW5jdGlvbiBgbWVhbmAgaW4gZWFybGllciBtb2R1bGVzKSwgYW5kIHdlIHNob3cgZXhhbXBsZSBjb2RlIGJlbG93IGZvciBjb21wdXRpbmcgdGhlc2UgZGVzY3JpcHRpdmUgc3RhdGlzdGljcyBvbiBhIHNpbmdsZSBjb2x1bW4gb2YgZGF0YSBmcm9tIHRoZSBwZW5ndWlucyBkYXRhIHNldC4KCk5vdGUgdGhhdCB0aGUgcGVuZ3VpbnMgZGF0YSBoYXMgc29tZSBtaXNzaW5nIHNvbWUgdmFsdWVzIChjZi4gTW9kdWxlIDAzIC0gU3Vic2V0dGluZyksIFRoZSBmdW5jdGlvbnMgZm9yIG1lYW4gYW5kIG1lZGlhbiB3aWxsIG5vdCB3b3JrIGlmIHRoZSBpbnB1dCBkYXRhIGhhdmUgYW55IGBOQWAgKG1pc3NpbmcpIHZhbHVlcy4gVGhlIG1vc3QgY29tbW9uIHNvbHV0aW9uIGlzIHRvIG9taXQgdGhvc2Ugc2NvcmVzIGZyb20gdGhlIGNvbXB1dGF0aW9uIGJ5IHNldHRpbmcgdGhlIGBuYS5ybWAgYXJndW1lbnQgdG8gYFRSVUVgIGFzIHNob3duOgoKCiMjIE1lYW4KCmBgYHtyIG1lYW4sIHdhcm5pbmc9RkFMU0UsIG1lc3NhZ2U9RkFMU0V9CiMgV2UgaGF2ZSBzZWVuIHRoaXMgY29kZSBiZWZvcmUuLi4gV2UgcGFzcyB0aGUgY29sdW1uIG9mIGludGVyZXN0CiMgdG8gZnVuY3Rpb24gbWVhbgptZWFuKHBlbmd1aW5zJGJvZHlfbWFzc19nLCBuYS5ybT1UUlVFKQpgYGAKCiMjIE1lZGlhbgoKYGBge3IgbWVkaWFuLCB3YXJuaW5nPUZBTFNFLCBtZXNzYWdlPUZBTFNFfQojIFRoZSBmYW1pbGlhciBwYXR0ZXJuLi4uLgptZWRpYW4ocGVuZ3VpbnMkYm9keV9tYXNzX2csIG5hLnJtID0gVFJVRSkKYGBgCgojIyBNb2RlCgpCYXNlIFIgaGFzIG5vIGJ1aWx0LWluIGZ1bmN0aW9uIGZvciBtb2RlLiBBZnRlciBNb2R1bGUgMDggeW91IHdpbGwgYmUgYWJsZSB0byB3cml0ZSB5b3VyIG93biBNb2RlIGZ1bmN0aW9uLiBPciB5b3UgY2FuIHVzZSBvbmUgb2Ygc2V2ZXJhbCBhdmFpbGFibGUgaW4gYXV4aWxpYXJ5IGxpYnJhcmllcy4gVGhlIERlc2NUb29scyBsaWJyYXJ5IGlzIGEgZ29vZCBvbmUuCgpgYGB7ciBtb2RlLCB3YXJuaW5nPUZBTFNFLCBtZXNzYWdlPUZBTFNFfQoKIyBJbnN0YWxsIHRoZSBwYWNrYWdlIG9uY2Ugb24gZWFjaCBtYWNoaW5lCiMgaW5zdGFsbC5wYWNrYWdlcygiRGVzY1Rvb2xzIikKCiMgTG9hZCB0aGUgbGlicmFyeSBvbmNlIGVhY2ggc2Vzc2lvbgpsaWJyYXJ5KERlc2NUb29scykKCiNDYWxsIHRoZSBmdW5jdGlvbgpNb2RlKHBlbmd1aW5zJGJvZHlfbWFzc19nLCBuYS5ybT1UUlVFKQoKYGBgCgpOb3RlIHRoYXQgRGVzY1Rvb2xzOjpNb2RlIHJldHVybnMgdGhlIG1vZGFsIChpLmUuIG1vc3QgY29tbW9uIHZhbHVlKSB3aXRoIGFuIGF0dGFjaGVkICoqYXR0cmlidXRlKiogY2FsbGVkICJmcmVxIiBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIG9jY3VycmVuY2VzLgoKIyMgVXNpbmcgZnVuY3Rpb24gYHN1bW1hcnlgCgpXaGVuIHlvdSBoYXZlIGEgdmVyeSBsYXJnZSBudW1iZXIgb2YgZGF0YSBtZWFzdXJlcywgeW91IG1heSB3aXNoIHRvIGNvbXB1dGUgTUNUcyBmb3IgaW5kaXZpZHVhbCBjb2x1bW5zIGFzIHNob3duIGFib3ZlLiBBbiBlZmZpY2llbnQgYWx0ZXJuYXRpdmUgZm9yIHNtYWxsZXIgZGF0YSBzZXRzIGlzIHRvIHVzZSBmdW5jdGlvbiBgc3VtbWFyeWAsIHdoaWNoIGFjY2VwdHMgYSBkYXRhIGZyYW1lIGFuZCBzdW1tYXJpc2VzICphbGwqIGl0cyBjb2x1bW5zIGF0IG9uY2UuIEZ1bmN0aW9uIGBzdW1tYXJ5YCBjb21wdXRlcyBmcmVxdWVuY2llcyBmb3IgY2F0ZWdvcmljYWwgdmFyaWFibGVzLCBhbmQgbWVhc3VyZXMgb2YgY2VudHJhbCB0ZW5kZW5jeSBmb3IgY29udGludW91cyB2YXJpYWJsZXMuIEl0IGFsc28gcmVwb3J0cyB0aGUgbnVtYmVycyBvZiBOQSB2YWx1ZXMgaW4gZWFjaCBjb2x1bW4uIEZ1bmN0aW9uIGBzdW1tYXJ5YCBwcm92aWRlcyBzb21lIGFkZGl0aW9uYWwgbWVhc3VyZXMgKG1pbmltdW0sIDFzdCBxdWFydGlsZSwgM3JkIHF1YXJ0aWxlLCBhbmQgbWF4aW11bSkgdGhhdCB3ZSB3aWxsIGRpc2N1c3MgaW4gbW9yZSBkZXRhaWwgbGF0ZXIuCgpgYGB7ciBzdW1tYXJ5fQpzdW1tYXJ5KHBlbmd1aW5zKQpgYGAKCiMjIyBFeGVyY2lzZQoKVGhlIHJlc3VsdHMgZm9yIGNvbHVtbiBgeWVhcmAgbWF5IG5vdCBiZSB3aGF0IHlvdSBleHBlY3RlZC4gRnVuY3Rpb24gYHN1bW1hcnlgIGhhcyBjb21wdXRlZCBhbiAqYXZlcmFnZSB2YWx1ZSogZm9yIGB5ZWFyYC4gRG9lcyB0aGlzIHNlZW0gbGlrZSB0aGUgYXBwcm9wcmlhdGUgYW5hbHlzaXM/IChBbnN3ZXIgPT4gTm8uKSBNb2RpZnkgYHBlbmd1aW5zYCB0byBtYWtlIGBzdW1tYXJ5YCB0cmVhdCB0aGUgYHllYXJgIGRhdGEgY29ycmVjdGx5LCBhbmQgcmVydW4gYHN1bW1hcnlgLgoKCiMgTWVhc3VyZXMgb2YgVmFyaWFiaWxpdHkKCkluIHRoZSBoaXN0b2dyYW1zIGZvciBDaGxBIGZyb20gZWFjaCBvZiB0aHJlZSBOZXcgWmVhbGFuZCBsYWtlcywgdGhlIHRocmVlIGdyb3VwcyBvZiBzY29yZXMgZGlkIG5vdCBvdmVybGFwIGNvbXBsZXRlbHksIGluZGljYXRpbmcgdGhhdCB0aGUgdHlwaWNhbCB2YWx1ZXMgLS0gdGhlIGNlbnRyYWwgdGVuZGVuY2llcyAtLSB3ZXJlIGRpZmZlcmVudCBmb3IgdGhlIHRocmVlIGxha2VzLiBXZSBjYW4gY29uZmlybSB0aGlzIG9ic2VydmF0aW9uIGJ5IGNvbXBhcmluZyB0aGUgbWVhbnMuIFdlIGNhbiB1c2UgZnVuY3Rpb24gYGFnZ3JlZ2F0ZWAgaW4gYmFzZSBSLCBvciBgZ3JvdXBfYnlgIGFuZCBgc3VtbWFyaXNlYCwgZnJvbSBsaWJyYXJ5IGRwbHlyLgoKIyMjIFVzaW5nIGBhZ2dyZWdhdGVgCgpgYGB7ciBsYWtlIG1lYW5zIDAxfQojIFVzaW5nIGFnZ3JlZ2F0ZS4gY29tcHV0ZSB0aGUgZ3JvdXAgbWVhbnMKYWdncmVnYXRlKGxha2VzJENobEEsIGJ5ID0gbGlzdChMYWtlID0gbGFrZXMkTGFrZU5hbWUpLCBGVU49bWVhbikKYGBgCgojIyMgVXNpbmcgYGdyb3VwX2J5YCBhbmQgYHN1bW1hcmlzZWAKCmBgYHtyIGxha2UgbWVhbnMgMDJ9CiMgVXNpbmcgYGdyb3VwX2J5YCBhbmQgYHN1bW1hcmlzZWAKbGlicmFyeShkcGx5cikKCmxha2VzICU+JSAKICBncm91cF9ieShMYWtlTmFtZSkgJT4lCiAgc3VtbWFyaXNlKE1lYW5DaGxBID0gbWVhbihDaGxBKSkKYGBgCgpIb3dldmVyLCBub3Qgb25seSBkbyB0aGUgY2VudHJhbCBwb2ludHMgb2YgdGhlIHRocmVlIGxha2VzJyBkaXN0cmlidXRpb25zIGRpZmZlciwgc28gZG8gdGhlIGFtb3VudHMgb2YgInNwcmVhZCIuIExha2UgVGF1cG8ncyBkaXN0cmlidXRpb24gaXMgdmVyeSAic2tpbm55IjsgYWxsIGl0cyByZWFkaW5ncyBhcmUgc2ltaWxhci4gTGFrZSBFbGxlc21lcmUgaXMgc3F1YXNoZWQgYW5kIHNwcmVhZCBvdXQ7IGl0cyByZWFkaW5ncyB2YXJ5IGEgbG90LiBMYWtlIFJvdG9ydWEgaXMgaW50ZXJtZWRpYXRlLiBUbyBpbGx1c3RyYXRlIHRoaXMgbW9yZSBjbGVhcmx5LCB3ZSBjYW4gdXNlIGdncGxvdCB0byBtYWtlIHNlcGFyYXRlIGdyYXBocyBmb3IgZWFjaCBsYWtlLCB1c2luZyBmdW5jdGlvbiBgZmFjZXRfZ3JpZGAuIAoKTm90ZSB0aGUgYHNjYWxlc2AgYXJndW1lbnQgdG8gYGZhY2V0X2dyaWRgLiBUaGlzIGFsbG93cyBlYWNoIGdyYXBoIHRvIGFkanVzdCBpdHMgeS1heGlzIHRvIGl0cyBkYXRhIGRvbWFpbiwgd2hpY2ggbWFrZXMgdGhlIGNvbXBhcmlzb24gdmlzdWFsbHkgZWFzaWVyOyB0aGlzIHNob3VsZCBiZSBtZW50aW9uZWQgaW4gdGhlIGRpc2N1c3Npb24gb2YgdGhlIGZpZ3VyZSBpbiBhIG1hbnVzY3JpcHQuCgojIyBVc2luZyBgZmFjZXRfZ3JpZGAKCmBgYHtyIGZhY2V0X2dyYXBocywgd2FybmluZz1GQUxTRSwgbWVzc2FnZT1GQUxTRX0KZ2dwbG90KGRhdGEgPSBsYWtlcykgKwogIGdlb21faGlzdG9ncmFtKGFlcyh4ID0gQ2hsQSwgZmlsbD1MYWtlTmFtZSksIGNvbG9yPSJibGFjayIpICsKICBmYWNldF9ncmlkKHJvd3MgPSB2YXJzKExha2VOYW1lKSwgc2NhbGVzPSJmcmVlX3kiKQpgYGAKClN0YXRpc3RpY2FsbHksIHRoZSAic3ByZWFkIG91dCIgcXVhbGl0eSBvZiBhIGRpc3RyaWJ1dGlvbiByZWZsZWN0cyBpdHMgKip2YXJpYWJpbGl0eSoqLgoKV2UgY2FuIGNhcHR1cmUgdmFyaWFiaWxpdHkgbW9yZSBwcmVjaXNlbHkgd2l0aCBtZWFzdXJlcyBvZiB0aGUgKipyYW5nZSoqIG9mIHRoZSBkYXRhIHNldC4gVGhlc2UgYXJlIHR5cGljYWxseSB0aGUgc21hbGxlc3QgYW5kIGxhcmdlc3Qgc2NvcmVzIChtaW5pbXVtIGFuZCBtYXhpbXVtKSBhbmQgdGhlIHNjb3JlcyBhdCB0aGUgMjV0aCBhbmQgNzV0aCBwZXJjZW50aWxlcyAoYWxzbyBjYWxsZWQgKioxc3QgcXVhcnRpbGUqKiBhbmQgKiozcmQgcXVhcnRpbGUqKikuIEVhcmxpZXIsIHdlIHNhdyB0aGF0IGZ1bmN0aW9uIGBzdW1tYXJ5YCBjb21wdXRlcyB0aGVzZSBtZWFzdXJlcyBvZiByYW5nZS4gSG93ZXZlciwgaWYgd2Ugc2ltcGx5IHBhc3MgdGhlIGVudGlyZSBgbGFrZXNgIGRhdGEgZnJhbWUgdG8gZnVuY3Rpb24gYHN1bW1hcnlgLCBpdCB3aWxsIGNvbWJpbmUgdGhlIGRhdGEgZnJvbSBhbGwgdGhyZWUgbGFrZXMgLS0gdG8gY29tcGFyZSB0aGUgbGFrZXMgd2UgbmVlZCB0aGUgdmFsdWVzIGZyb20gZWFjaCBsYWtlIHNlcGFyYXRlbHkuCgpJbiBlYXJsaWVyIG1vZHVsZXMgd2UgaGF2ZSBzZWVuIHR3byB0ZWNobmlxdWVzIGZvciBzZWxlY3Rpbmcgb3V0IGp1c3QgdGhlIHJvd3MgZnJvbSBvbmUgbGFrZSAodXNpbmcgW10gb3IgdXNpbmcgYGZpbHRlcmApLiBUbyBydW4gZnVuY3Rpb24gYHN1bW1hcnlgIG9uIGVhY2ggbGFrZSBzZXBhcmF0ZWx5LCB3ZSBjb3VsZCBzZWxlY3QgdGhlIHN1YnNldCBmb3IgZWFjaCBsYWtlIGluIHR1cm4sIGFuZCBwYXNzIGVhY2ggc3Vic2V0IHRvIGBzdW1tYXJ5YC4gSG93ZXZlciwgd2UgY2FuIGFjaGlldmUgdGhlIHNhbWUgcmVzdWx0IG1vcmUgcGFyc2ltb25pb3VzbHkgYnkgdXNpbmcgZnVuY3Rpb24gYGFnZ3JlZ2F0ZWAuIEFib3ZlIHdlIHVzZWQgYWdncmVnYXRlIHdpdGggYEZVTiA9IG1lYW5gIHRvIGdldCB0aGUgbWVhbiBDaGxBIGZvciBlYWNoIGxha2UuIFdlIGNhbiB1c2UgYEZVTiA9IHN1bW1hcnlgIHRvIGNhbGwgZnVuY3Rpb24gYHN1bW1hcnlgIHNlcGFyYXRlbHkgZm9yIHRoZSByZWNvcmRzIG9mIGVhY2ggbGFrZS4gCgpgYGB7ciBhZ2dyZWdhdGUgc3VtbWFyeX0KIyBBcHBseSBmdW5jdGlvbiBzdW1tYXJ5IGJ5IGdyb3VwCmFnZ3JlZ2F0ZShsYWtlcyRDaGxBLCBieSA9IGxpc3QoTGFrZSA9IGxha2VzJExha2VOYW1lKSwgRlVOPXN1bW1hcnkpCgpgYGAKCldlIGNhbiBhbHNvIG1lYXN1cmUgdGhlIHZhcmlhYmxpdHkgaW4gYSBkYXRhIHNldCB3aXRoIHRoZSAqKnN0YW5kYXJkIGRldmlhdGlvbioqLiBUaGUgc3RhbmRhcmQgZGV2aWF0aW9uIGlzIHRoZSBtb3N0IGNvbW1vbmx5IHVzZWQgbWVhc3VyZSBvZiB2YXJpYWJpbGl0eSwgYW5kIGl0IHBsYXlzIGFuIGltcG9ydGFudCBtYXRoZW1hdGljYWwgcm9sZSBpbiBpbmZlcmVudGlhbCBzdGF0aXN0aWNzIChhc2sgeW91ciBzdGF0cyBsZWN0dXJlciBmb3IgZGV0YWlscyAtLSBpdCdzIHZlcnkgaW50ZXJlc3RpbmcpLiBDb25jZXB0dWFsbHksIHRoZSBzdGFuZGFyZCBkZXZpYXRpb24gaXMgKmFsbW9zdCogZXF1YWwgdG8gdGhlIGF2ZXJhZ2UgZGlzdGFuY2UgZnJvbSB0aGUgbWVhbiBhY3Jvc3MgYWxsIHRoZSB2YWx1ZXMgaW4gYSBkYXRhIHNldCAtLSBpdCBkb2Vzbid0IGVxdWFsICpleGFjdGx5KiB0aGF0IHZhbHVlLCBiZWNhdXNlIG9mIGhvdyBpdCBpcyBjb21wdXRlZCwgYnV0IGl0IGlzIGNsb3NlLCBhbmQgaXQgY2FuIGJlIGhlbHBmdWwgdG8gdGhpbmsgb2YgaXQgd2l0aCB0aGlzIGFwcHJveGltYXRpb24uIEJpZyBzdGFuZGFyZCBkZXZpYXRpb24gc2hvd3MgdGhhdCBzY29yZXMgYXJlIHNwcmVhZCBmYXIgZnJvbSB0aGVpciBtZWFuOyBzbWFsbCBzdGFuZGFyZCBkZXZpYXRpb24gc2hvd3MgdGhhdCBzY29yZXMgdGVuZCB0byBodWRkbGUgY2xvc2UgdG8gdGhlaXIgbWVhbi4gQ29tcHV0ZSBzdGFuZGFyZCBkZXZpYXRpb24gd2l0aCBmdW5jdGlvbiBgc2RgLgoKIyMjIFVzaW5nIGBhZ2dyZWdhdGVgCgpgYGB7ciBzZH0KIyBVc2luZyBhZ2dyZWdhdGUuIGNvbXB1dGUgdGhlIGdyb3VwIHNkcwphZ2dyZWdhdGUobGFrZXMkQ2hsQSwgYnkgPSBsaXN0KExha2UgPSBsYWtlcyRMYWtlTmFtZSksIEZVTj1zZCkKYGBgCgojIyMgVXNpbmcgYGdyb3VwX2J5YCBhbmQgYHN1bW1hcmlzZWAKCmBgYHtyIHNkIGRwbHlyfQpsYWtlcyAlPiUgCiAgZ3JvdXBfYnkoTGFrZU5hbWUpICU+JQogIHN1bW1hcmlzZShTdGREZXYgPSBzZChDaGxBKSkKCmBgYAoKVGhlIGhpc3RvZ3JhbXMsIHRoZSBtZWFzdXJlcyBvZiByYW5nZSwgYW5kIHRoZSBzdGFuZGFyZCBkZXZpYXRpb25zIGFsbCBpbmRpY2F0ZSB0aGF0IFRhdXBvIGhhcyB2ZXJ5IHN0YWJsZSBDaGxBIG1lYXN1cmVzLCBSb3RvcnVhIGlzIGEgbGl0dGxlIG5vaXNpZXIsIGFuZCBFbGxlc21lcmUgaXMgYWxsIG92ZXIgdGhlIHBsYWNlLiBUaGlzIHBoeXRvcGxhbmt0b24gYmlvbWFzcyBzdGFiaWxpdHkgaXMgYW4gaW1wb3J0YW50IGluZGljYXRvciBvZiBsYWtlIGhlYWx0aCAtLSBhIHN0YWJsZSBsYWtlIGlzIGF0IG11Y2ggbG93ZXIgcmlzayBvZiBhIHRveGljIGFsZ2FsIGJsb29tLgoKCiMgRWZmaWNpZW50IGNvZGUgZm9yIGRlc2NyaXB0aXZlIHN0YXRpc3RpY3MKClRoZSBmdW5jdGlvbiBgZGVzY3JpYmVCeWAgaW4gcGFja2FnZSBgcHN5Y2hgIHdpbGwgIGNvbXB1dGUgYWxsIHRoZSBkZXNjcmlwdGl2ZSBzdW1tYXJpZXMgd2UgaGF2ZSBzZWVuIChhbmQgYSBmZXcgbW9yZSkgaW4gb25lIHN0YXRlbWVudC4gV2hlbiB5b3UgYXJlIGV4cGxvcmluZyBhIHNpbmdsZSBkYXRhIGNvbHVtbiBhbmQgYSBzaW5nbGUgZ3JvdXBpbmcgY29sdW1uIChzbyB0aGUgb3V0cHV0IGRvZXNuJ3QgZ2V0IHRvbyBsYXJnZSksIHRoaXMgaXMgYSB2ZXJ5IHVzZWZ1bCBmdW5jdGlvbi4gCgpgYGB7ciBwc3ljaH0KIyBJbnN0YWxsIG9uY2Ugb24gYW55IGNvbXB1dGVyCiNpbnN0YWxsLnBhY2thZ2VzKCJwc3ljaCIpCgojIENhbGwgb25jZSBlYWNoIFIgc2Vzc2lvbgpsaWJyYXJ5KHBzeWNoKQoKIyBQYXNzIGluIHRoZSBkYXRhIGNvbHVtbiBhbmQgdGhlIGdyb3VwaW5nIGNvbHVtbgpkZXNjcmliZUJ5KGxha2VzJENobEEsIGxha2VzJExha2VOYW1lKQpgYGAKClBhY2thZ2UgYHBzeWNoYCBjb250YWlucyBtYW55IG90aGVyIGludGVyZXN0aW5nIHN0YXRpc3RpY2FsIHRvb2xzLCBlc3BlY2lhbGx5IGZvciBtdWx0aXZhcmlhdGUgZGF0YSBzZXRzIGNvbW1vbmx5IGZvdW5kIGluIHBzeWNob2xvZ2ljYWwgYW5kIGVjb2xvZ2ljYWwgcmVzZWFyY2guIEFzayBHb29nbGUgb3IgeW91ciBsZWN0dXJlciBmb3IgZGV0YWlscy4KCiMgRXhwbG9yaW5nIHRoZSByZWxhdGlvbnNoaXAgYmV0d2VlbiB0d28gdmFyaWFibGVzCgpUaGUgcHJlY2VkaW5nIGRlc2NyaXB0aXZlIHN0YXRpc3RpY3MgYWxsIGxvb2tlZCBhdCBkYXRhIG1lYXN1cmVzIC0tIENobEEsIGJpbGwgbGVuZ3RoLCBib2R5IHdlaWdodCwgZXRjLiAtLSBpbmRpdmlkdWFsbHksIHN1bW1hcmlzaW5nIHRoZWlyIGRpc3RyaWJ1dGlvbiwgY2VudHJhbCB0ZW5kZW5jeSBhbmQgdmFyaWFiaWxpdHkuIE9mdGVuLCBob3dldmVyLCB3ZSBhcmUgaW50ZXJlc3RlZCBpbiBkZXNjcmliaW5nICoqdGhlIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIGRhdGEgbWVhc3VyZXMqKi4gRm9yIGV4YW1wbGUsIHdlIG1pZ2h0IHdhbnQgdG8ga25vdyBpZiBoZWF2aWVyIHBlbmd1aW5zIGFsc28gdGVuZCB0byBoYXZlIGxvbmdlciBiaWxscy4gVGhpcyB0eXBlIG9mIHJlbGF0aW9uc2hpcCBpcyBjYWxsZWQgYSAqKmNvcnJlbGF0aW9uKiouIFdoZW4gd2UgaGF2ZSBtb3JlIHRoYW4gb25lIG1lYXN1cmUgZm9yIGVhY2ggZXhwZXJpbWVudGFsIHBhcnRpY2lwYW50IChvciBlYWNoIHBlbmd1aW4sIG9yIGVhY2ggbGFrZSkgd2UgY2FuIGV4cGxvcmUgY29ycmVsYXRpb25zIGJldHdlZW4gcGFpcnMgb2YgbWVhc3VyZXMgZ3JhcGhpY2FsbHkgd2l0aCBhICoqc2NhdHRlcnBsb3QqKi4gQSBzY2F0dGVycGxvdCBoYXMgb25lIG1lYXN1cmUgb24gZWFjaCBheGlzLCBhbmQgb25lIHBvaW50IGZvciBlYWNoIHBhcnRpY2lwYW50J3MgcGFpciBvZiBzY29yZXMuCgpJbiB0aGUgY29kZSBleGFtcGxlIGJlbG93IHdlIG1ha2UgYSBzY2F0dGVycGxvdCB3aXRoIGdncGxvdCAoY2YuIE1vZHVsZSAwMiksIGFuZCBzaG93IGhvdyB0byBhZGQgYSAqKmxpbmVhciB0cmVuZCBsaW5lKiouIENvbmNlcHR1YWxseSwgdGhpcyBpcyB0aGUgbGluZSB0aGF0IHJ1bnMgdGhyb3VnaCB0aGUgY2VudGVyIG9mIHRoZSBzY2F0dGVycGxvdCBwb2ludHMsIGFuZCBpdCBoZWxwcyB1cyB0byBzZWUgdGhlIGRpcmVjdGlvbiBvZiB0aGUgcmVsYXRpb25zaGlwLiBNYXRoZW1hdGljYWxseSwgdHJlbmQgbGluZXMgYXJlIGFjdHVhbGx5IHZlcnkgY29tcGxpY2F0ZWQgdGhpbmdzLCBhbmQgd2UgZ2VuZXJhdGUgdGhlbSB3aXRoIHRoZSBwb3dlcmZ1bCBmdW5jdGlvbiBgbG1gLChmb3IgKipsaW5lYXIgbW9kZWwqKikuIFlvdSB3aWxsIGxlYXJuIGFib3V0IHRoZSBtYW55IGZhc2NpbmF0aW5nIHRoaW5ncyB5b3UgY2FuIGRvIHdpdGggbGluZWFyIG1vZGVsaW5nIGlmIHlvdSB0YWtlIGFkdmFuY2VkIHN0YXRpc3RpY3MgcGFwZXJzLgoKIyMgU2NhdHRlcnBsb3Qgd2l0aCBsaW5lYXIgdHJlbmQgbGluZQoKYGBge3IgMDQtc2NhdHRlcnBsb3QsIHdhcm5pbmc9RkFMU0UsIG1lc3NhZ2U9RkFMU0V9CiMgZ2VvbV9wb2ludCBwbG90cyB0aGUgcG9pbnRzIG9mIHRoZSBzY2F0dGVycGxvdCAKCiMgZ2VvbV9zbW9vdGggcGxvdHMgdGhlIGxpbmVhciB0cmVuZCBsaW5lIGNvbXB1dGVkIHdpdGggZnVuY3Rpb24gbG0KCiMgVGhlIHNlIGFyZ3VtZW50IGRldGVybWluZXMgd2hldGhlciBlcnJvciBiYXJzIGFyZSBzaG93biAKIyBhcm91bmQgdGhlIHRyZW5kIGxpbmUuCgpnZ3Bsb3QoZGF0YSA9IHBlbmd1aW5zLCBtYXBwaW5nID0gYWVzKHggPSBib2R5X21hc3NfZywgeSA9IGJpbGxfbGVuZ3RoX21tKSkgKwogIGdlb21fcG9pbnQoKSArCiAgZ2VvbV9zbW9vdGgobWV0aG9kID0gImxtIiwgc2U9RkFMU0UpCgpgYGAKClRoZSBzY2F0dGVycGxvdCBnaXZlcyB1cyBhIHZlcnkgY2xlYXIgcGljdHVyZTogdGhvc2UgcGVuZ3VpbnMgd2l0aCBoaWdoZXIgYm9keSB3ZWlnaHRzIHRlbmQgdG8gYWxzbyBoYXZlIGxvbmdlciBiaWxscywgYW5kIHRoaXMgaXMgcmVmbGVjdGVkIGluIHRoZSBwb3NpdGl2ZSBzbG9wZSBvZiB0aGUgdHJlbmRsaW5lLiBOb3RlIGhvd2V2ZXIgdGhhdCB0aGlzIGlzIG5vdCBhbiBhYnNvbHV0ZSBydWxlLiBJcyBpdCBlYXN5IHRvIGZpbmQgcGFpcnMgb2YgcG9pbnRzIHN1Y2ggdGhhdCB0aGUgbGlnaHRlciBvZiB0d28gcGVuZ3VpbnMgaGFzIHRoZSBsb25nZXIgYmlsbC4gVGhpcyBpcyB0eXBpY2FsIG9mIGNvcnJlbGF0aW9uYWwgZGF0YS4gCgpUaGVyZSBhcmUgdmFyaW91cyBzdGF0aXN0aWNhbCBtZWFzdXJlcyB0aGF0IGNhcHR1cmUgdGhlIHN0cmVuZ3RoIG9mIGEgY29ycmVsYXRpb24gKGkuZS4gaG93IGNsb3NlIGl0IGlzIHRvIGJlaW5nIGFuIGFic29sdXRlIHJ1bGUpLiBGb3IgY29udGludW91cywgbnVtZXJpY2FsIGRhdGEgKHN1Y2ggYXMgYmlsbCBsZW5ndGggYW5kIGJvZHkgd2VpZ2h0KSB1c2UgdGhlIFIgZnVuY3Rpb24gYGNvcmAgdG8gY29tcHV0ZSB0aGUgbnVtZXJpY2FsIGNvcnJlbGF0aW9uIHZhbHVlLiBBcyB3aXRoIG1lYW5zIGFuZCBtZWRpYW5zLCB3ZSBtdXN0IHRlbGwgYGNvcmAgaG93IHRvIGNvcGUgd2l0aCBtaXNzaW5nIGRhdGEgKE5BIHNjb3JlcykuIFVuZm9ydHVuYXRlbHkgdGhlIHN5bnRheCBpcyBub3QgY29uc2lzdGVudCBhY3Jvc3MgdGhlIGZ1bmN0aW9ucy4gRm9yIGZ1bmN0aW9uIGBtZWFuYCB3ZSBzZXQgYXJndW1lbnQgYG5hLnJtID0gVFJVRWAuIEZvciBmdW5jdGlvbiBgY29yYCB3ZSBtdXN0IHNldCBhcmd1bWVudCBgdXNlID0gImNvbXBsZXRlLm9icyJgLCBtZWFuaW5nIHRoYXQgd2Ugd2FudCB0aGUgZnVuY3Rpb24gdG8gdXNlIG9ubHkgdGhvc2Ugcm93cyB0aGF0IGFyZSBjb21wbGV0ZSAoaS5lLiBoYXZlIGJvdGggdmFsdWVzKS4gVGhlc2UgaWRpb3N5bmNyYWNpZXMgb2NjdXIgZnJvbSB0aW1lIHRvIHRpbWUgaW4gUjsgeW91IGp1c3QgaGF2ZSB0byBsZWFybiB0aGVtLgoKIyMgQ29ycmVsYXRpb24gY29lZmZpY2llbnQKCmBgYHtyIGNvcn0KCiMgUGFzcyB0aGUgdHdvIGRhdGEgY29sdW1ucyBpbnRvIGZ1bmN0aW9uIGNvcgpjb3IocGVuZ3VpbnMkYmlsbF9sZW5ndGhfbW0sIHBlbmd1aW5zJGJvZHlfbWFzc19nLCB1c2U9ImNvbXBsZXRlLm9icyIpCmBgYAoKRnVuY3Rpb24gYGNvcmAgcmV0dXJucyBhIHZhbHVlIGJldHdlZW4gLTEgYW5kIDEuIENvcnJlbGF0aW9ucyB0aGF0IHRyZW5kIGRvd253YXJkIChpLmUuIGlmIG9uZSBzY29yZSBpcyBoaWdoLCB0aGUgb3RoZXIgdGVuZHMgdG8gYmUgbG93KSB3aWxsIGhhdmUgYSBuZWdhdGl2ZSBjb3JyZWxhdGlvbiB2YWx1ZS4gQ29ycmVsYXRpb25zIHRoYXQgdHJlbmQgdXB3YXJkIChpLmUuIGlmIG9uZSBzY29yZSBpcyBoaWdoIHRoZSBvdGhlciBhbHNvIHRlbmRzIHRvIGJlIGhpZ2gpIHdpbGwgaGF2ZSBhIHBvc2l0aXZlIGNvcnJlbGF0aW9uIHZhbHVlLiBUaGUgY2xvc2VyIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiBgY29yYCBpcyB0byAxLCB0aGUgc3Ryb25nZXIgdGhlIGNvcnJlbGF0aW9uICh5b3Uga25vdyB3aG8gdG8gdGFsayB0byBmb3IgbW9yZSBkZXRhaWwsIGRvbid0IHlvdT8pLgoKRm9yIGV4YW1wbGUsIGNvbnNpZGVyIHRoZXNlIHR3byBzY2F0dGVycGxvdHM6CgpgYGB7ciAwNC1jb21wYXJpbmcsIGVjaG89RkFMU0UsIHdhcm5pbmc9RkFMU0UsIG1lc3NhZ2U9RkFMU0V9CmxpYnJhcnkoZ3JpZEV4dHJhKQpwbG90MSA8LSBnZ3Bsb3QoZGF0YSA9IHBlbmd1aW5zLCBtYXBwaW5nID0gYWVzKHggPSBib2R5X21hc3NfZywgeSA9IGJpbGxfbGVuZ3RoX21tKSkgKwogIGdlb21fcG9pbnQoKSArCiAgZ2VvbV9zbW9vdGgobWV0aG9kID0gImxtIiwgc2U9RkFMU0UpCnBsb3QyIDwtIGdncGxvdChkYXRhID0gcGVuZ3VpbnMsIG1hcHBpbmcgPSBhZXMoeCA9IGJvZHlfbWFzc19nLCB5ID0gZmxpcHBlcl9sZW5ndGhfbW0pKSArCiAgZ2VvbV9wb2ludCgpICsKICBnZW9tX3Ntb290aChtZXRob2QgPSAibG0iLCBzZT1GQUxTRSkKZ3JpZC5hcnJhbmdlKHBsb3QxLCBwbG90MiwgbmNvbD0yKQpgYGAKCmBgYHtyIGNvciBleGVyY2lzZSBzb2x1dGlvbiwgZWNobz1GQUxTRSwgaW5jbHVkZT1GQUxTRX0KY29yKHBlbmd1aW5zJGJvZHlfbWFzc19nLCBwZW5ndWlucyRiaWxsX2xlbmd0aF9tbSwgdXNlPSJjb21wbGV0ZS5vYnMiKQoKY29yKHBlbmd1aW5zJGJvZHlfbWFzc19nLCBwZW5ndWlucyRmbGlwcGVyX2xlbmd0aF9tbSwgdXNlPSJjb21wbGV0ZS5vYnMiKQpgYGAKCiMjIEV4ZXJjaXNlCgpGb3Igb25lIG9mIHRoZSBzY2F0dGVycGxvdHMgYWJvdmUsIHRoZSBjb21wdXRlZCBjb3JyZWxhdGlvbiBzY29yZSBpcyAwLjYwLiBGb3IgdGhlIG90aGVyLCBpdCBpcyAwLjg3LiBGaXJzdCwgcHJlZGljdCB3aGljaCBpcyB3aGljaC4gU2Vjb25kLCB3cml0ZSB0aGUgbmVjZXNzYXJ5IFIgY29kZSB0byBjb25maXJtIHlvdXIgcHJlZGljdGlvbi4K</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("04-summarise.Rmd");
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
